# -*- coding: utf-8 -*-
"""②Opinion_Dynamics_Extended.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pETBdDC33LtBqTopMcq9jEn7iNTAwsgC
"""

!pip install peakutils
import numpy as np
import networkx as nx
import pandas as pd
import scipy.stats as stats
import matplotlib.pyplot as plt
import peakutils
import os
import math
import datetime
import copy
import random
import matplotlib.colors as mcolors

#agent
class Agent(object):
    def __init__(self, user_id, epsilon, screen_diversity):
        self.user_id = user_id
        self.opinion = np.random.uniform(-1.0, 1.0)
        self.epsilon = epsilon
        self.screen_diversity = screen_diversity
        self.orig_msg_ids_in_screen = []
 
        
    def set_orig_msg_ids_in_screen(self, screen):
        self.orig_msg_ids_in_screen = screen.orig_msg_id.values

        
    def evaluate_messages(self, screen):
        self.concordant_msgs = []
        self.discordant_msgs = []
        if len(screen) > 0:
            self.concordant_msgs = screen[abs(self.opinion - screen.content) < self.epsilon]
            self.discordant_msgs = screen[abs(self.opinion - screen.content) >= self.epsilon]


    def update_opinion(self, mu):
        if len(self.concordant_msgs) > 0:
            self.opinion = self.opinion + mu * np.mean(self.concordant_msgs.content - self.opinion)

            
    def post_message(self, msg_id, p):
        if len(self.concordant_msgs) > 0 and np.random.random() < p:
            # repost a friend's message selected at random
            idx = np.random.choice(self.concordant_msgs.index)
            selected_msg = self.concordant_msgs.loc[idx]
            return Message(msg_id=int(msg_id), orig_msg_id=int(selected_msg.orig_msg_id),
                           who_posted=int(self.user_id), who_originated=int(selected_msg.who_originated),
                           content=selected_msg.content)
        else:
            # post a new message
            new_content = self.opinion
            return Message(msg_id=int(msg_id), orig_msg_id=int(msg_id),
                           who_posted=int(self.user_id), who_originated=int(self.user_id), content=new_content)

        
    def decide_follow_id_at_random(self, friends, total_number):
        prohibit_list = friends + [self.user_id]
        return int(np.random.choice([i for i in range(total_number) if i not in prohibit_list]))

    def decide_unfollow_id_at_random(self, discordant_messages):
        unfollow_candidates = discordant_messages.who_posted.values
        return int(np.random.choice(unfollow_candidates))

    def decide_to_rewire(self, social_media, following_methods, num_media_agents):
        unfollow_id = None
        follow_id = None

        if len(self.discordant_msgs) > 0:
            #decide whom to unfollow
            unfollow_id = self.decide_unfollow_id_at_random(self.discordant_msgs)
            #decide whom to follow
            following_method = np.random.choice(following_methods)
            #G.neighbors(α)の場合、アルファのノードから出る有向辺が示すノードを示す
            friend = social_media.G.neighbors(self.user_id)
            friends = list(friend)

            #Repost-based selection if possible; otherwise random selection
            if following_method == 'Repost':
                friends_of_friends = list(set(self.concordant_msgs.who_originated.values) - set(friends) - set([self.user_id]))
                if len(friends_of_friends) > 0:
                    follow_id = int(np.random.choice(friends_of_friends))
                else:
                    follow_id = self.decide_follow_id_at_random(friends, social_media.G.number_of_nodes())

            #Recommendation-basd selection if possible; otherwise random selection
            elif following_method == 'Recommendation':
                similar_agents = social_media.recommend_similar_users(self.user_id, self.epsilon, social_media.G.number_of_nodes(), num_media_agents)
                if len(similar_agents) > 0:
                    follow_id = int(np.random.choice(similar_agents))
                else:
                    follow_id = self.decide_follow_id_at_random(friends, social_media.G.number_of_nodes())

            # Random selection
            else:
                follow_id = self.decide_follow_id_at_random(friends, social_media.G.number_of_nodes())

        return unfollow_id, follow_id


class Media(object):
  def __init__(self, media_id, opinion, omega, delta):
    self.media_id = media_id
    # self.media_opinion = np.random.uniform(-1.0, 1.0)
    self.media_opinion = opinion 
    self.delta = delta
    self.follower_agent_list = []

  def evaluate_follower_old(self, social_media, agent_opinion, change_methods, num_agents, num_media_agents, delta):
    if change_methods == "neighbor":
      #このfollowerリストにメディアのフォロワーを格納する。
      follower = []
      a = social_media.G.in_edges(self.media_id)
      a = list(a)
      for j in range(len(a)):
        k = a[j][0]
        follower.append(k)
      # follower = list(social_media.G.neighbors(self.media_id))
      self.follower_agent_list = follower
      total = 0
      for i in self.follower_agent_list:
        total += agent_opinion[-1][i]
      total = total / len(self.follower_agent_list)
      return total
    
    elif change_methods == "opinion_poll":#世論調査
      total = 0
      count = 0
      media_list = [j+num_agents for j in range(num_media_agents)]
      for i in range(social_media.num_agents):
        if delta > abs(agent_opinion[-1][i] - (self.media_opinion)):
          count += 1
          total += agent_opinion[-1][i]
      if count == 0:
        total = 0
      else:
        total = total / count
      return total

  def evaluate_follower_new(self, social_media, agent_opinion, change_methods, delta):
    if change_methods == "neighbor":
      agents_id = []
      a = social_media.G.in_edges(self.media_id)
      a = list(a)
      for j in range(len(a)):
        k = a[j][0]
        agents_id.append(k)
      return agents_id
    
    elif change_methods == "opinion_poll":
      total = 0
      count = 0
      agents_id = []
      media_list = [j+social_media.num_agents for j in range(social_media.num_media_agents)]
      for i in range(social_media.num_agents):
        if delta > abs(agent_opinion[-1][i] - self.media_opinion):
          count += 1
          agents_id.append(i)
      return agents_id

    #メディアは人数が多い方を選ぶと思うが、delta以内に賛成が1人、反対が0人の場合と、delta以内に賛成が50人、反対が0人の場合とでは意見変更の度合いは異なるのか？

  def update_media_opinion(self, opinion_data, omega, agents_id):
    if len(agents_id) != 0:
      opinion_list = [opinion_data[-1][i] - self.media_opinion for i in agents_id]
      self.media_opinion = self.media_opinion + omega * np.mean(opinion_list)

    
  def post_media_messages(self, msg_id):
    media_new_content = self.media_opinion
    return Message(msg_id = int(msg_id), orig_msg_id = int(msg_id), who_posted = int(self.media_id),
                   who_originated = int(self.media_id), content = media_new_content)


################################################################################################################################################################

#social_media

class Message(object):
    def __init__(self, msg_id, orig_msg_id, who_posted, who_originated, content):
        self.msg_id = msg_id
        self.orig_msg_id = orig_msg_id
        self.who_posted = who_posted
        self.who_originated = who_originated
        self.content = content


    def to_dict(self):
        return {'msg_id': self.msg_id, 'orig_msg_id':self.orig_msg_id,
                'who_posted':self.who_posted, 'who_originated':self.who_originated,
                'content':self.content,}




# #num_media_agentsとnum_media_linksを新たな引数を渡す
class SocialMedia(object):
    def __init__(self, num_agents, num_media_agents, num_links, num_media_links, l, sns_seed):
        self.num_agents = num_agents
        self.num_media_agents = num_media_agents
        random_state = np.random.RandomState(sns_seed)
        #今回の有向グラフにおいてAからBに有向辺が存在する場合、AはBをフォローしているという意味であり、BはAの友達である。つまりA's friend = B
        self.K = nx.gnm_random_graph(n=num_agents, m=num_links, seed=random_state, directed=True)
        self.modify_random_graph()
        self.H = nx.DiGraph()#
        self.H.add_nodes_from([i for i in range(self.num_agents + self.num_media_agents)])#
        media_edge_list = self.media_edges(self.num_agents, self.num_media_agents, num_media_links)#
        self.H.add_edges_from(media_edge_list)#
        self.media_modify_random_graph(self.num_agents, self.num_media_agents)#
        self.G = nx.compose(self.K, self.H)
        self.message_dic = {}
        self.message_df = pd.DataFrame(columns=['msg_id', 'orig_msg_id', 'who_posted', 'who_originated', 'content'])
        self.screen_size = l
    
        #ユーザーエージェントが0から99まである。よってメディアは数が4だとしたら100から103まである。
    def media_edges(self, num_agents, num_media_agents, num_media_links):#
         #有向辺を格納するためのリスト
        media_edge_list = []
        for i in range(num_media_agents):
           count = 1
           i += num_agents
          #  [random.randint(0, num_agents) for i in range(int(num_media_links/num_media_agents))]
           while count <= num_media_links/num_media_agents:
            j = random.randint(0, num_agents-1)
            if [j, i] not in media_edge_list:
              media_edge_list.append([j, i])
              count += 1
        return media_edge_list

    #メディアからの入次数が0のノードが存在する場合、入次数を変更
    def media_modify_random_graph(self, num_agents, num_media_agents):
        media_list = [j+num_agents for j in range(num_media_agents)]
        # print(self.H.out_degree())
        # print([k for k, v in list(self.H.out_degree()) if v == 0 and k not in media_list])

        for no_outdegree_node in [k for k, v in list(self.H.out_degree()) if v == 0 and k not in media_list]:
          target_node = np.random.choice([k for k, v in list(self.H.out_degree()) if v >= 2 and k not in media_list])
          i = np.random.choice(len(self.H.edges(target_node)))
          target_edge = list(self.H.edges(target_node))[i]
          self.H.remove_edge(target_edge[0], target_edge[1])
          self.H.add_edge(no_outdegree_node, target_edge[1])

    def modify_random_graph(self):
        for no_outdegree_node in [k for k, v in list(self.K.out_degree()) if v == 0]:
            target_node = np.random.choice([k for k, v in list(self.K.out_degree()) if v >= 2])
            i = np.random.choice(len(self.K.edges(target_node)))
            target_edge = list(self.K.edges(target_node))[i]
            self.K.remove_edge(target_edge[0], target_edge[1])
            self.K.add_edge(no_outdegree_node, target_edge[1])


    def set_node_colors(self, node_colors):
        for i, c in enumerate(node_colors):
            self.G.nodes[i]['color'] = c


    def show_screen(self, user_id):
        friends = self.G.neighbors(user_id)
        friend_message_df = self.message_df[self.message_df['who_posted'].isin(friends)]
        friend_message_df = friend_message_df[friend_message_df['who_originated'] != user_id]
        return friend_message_df.tail(self.screen_size)


    def update_message_db(self, t, msg):
        self.message_df = self.message_df.append(msg.to_dict(), ignore_index=True).tail(self.num_agents)


    def recommend_similar_users(self, user_id, epsilon, num_agents, num_media_agents):
        similar_users = []
        #自分が投稿した最新のメッセージを一つ取り出している
        my_message_df = self.message_df[self.message_df.who_originated == user_id].tail(1)

        #もし自分の投稿したメッセージが存在する場合
        if len(my_message_df) > 0:
            #.contentは既に定義した 
            last_message = my_message_df.content.values[0]
            #友達を取得
            friends = self.G.neighbors(user_id)
            friends = list(friends)
            #これまで取得してきた自分を含まないメッセージのデータのうち、全エージェント数分だけの最新のメッセージを取得。このようにある程度の数を取得しないと、自分と意見の一致する投稿が見つからないかもしれない。
            similar_messages_df = self.message_df[self.message_df.who_originated != user_id].tail(num_agents+num_media_agents)
            #閾値を適用して自分と意見の近いメッセージのみを取得 この場合last_messageが今の意見なのか前のメッセージを作成した時の意見なのか不明?
            similar_messages_df = similar_messages_df[abs(last_message - similar_messages_df.content) < epsilon]
            #もしこのような意見の近いメッセージが存在するならばという条件分岐
            if len(similar_messages_df) > 0:
                #これまで自分が取得した意見の近いメッセージの投稿者のうち友達ではない人を取得
                similar_users = [u for u in similar_messages_df.who_originated.values if u not in friends]
        return similar_users


    def rewire_users(self, user_id, unfollow_id, follow_id):
        self.G.remove_edge(user_id, unfollow_id)
        self.G.add_edge(user_id, follow_id)

################################################################################################################################################################

#analysis

def screen_diversity(content_values, bins):
    h, w = np.histogram(content_values, range=(-1, 1), bins=bins)
    return stats.entropy(h+1, base=2)


def num_opinion_peaks(opinions):
    nparam_density = stats.kde.gaussian_kde(opinions)
    x = np.linspace(-1, 1, 100)
    density = nparam_density(x)
    indexes = peakutils.indexes(density, thres=0, min_dist=10)
    print(x[indexes], density[indexes])
    return len(indexes)

################################################################################################################################################################
#echo_chamber_dynamics

class EchoChamberDynamics(object):
    def __init__(self, num_agents, num_media_agents, num_links, num_media_links, epsilon, sns_seed, l, data_dir, opinion_list):
        self.num_agents = num_agents
        self.l = l
        self.epsilon = epsilon
        self.set_agents(num_agents, epsilon)
        self.set_media(num_media_agents, opinion_list, num_agents, omega, delta)
        self.social_media = SocialMedia(num_agents, num_media_agents, num_links, num_media_links, l, sns_seed)
        self.data_dir = data_dir
        self.opinion_data = []
        self.opinion_media_data = []
        self.screen_diversity_data = []
        #ファイルの作成は必要ないので#
        # if not os.path.isdir(data_dir):
            # os.makedirs(os.path.join(data_dir, 'data'))
            # os.makedirs(os.path.join(data_dir, 'network_data'))

            
    def set_agents(self, num_agents, epsilon):
        screen_diversity_a = screen_diversity([], bins=10)
        self.agents = [Agent(i, epsilon, screen_diversity_a) for i in range(num_agents)]
    
    def set_media(self, num_media_agents, opinion_list, num_agents, omega, delta):
        self.medias = [Media(j+num_agents, opinion_list[j], omega, delta) for j in range(num_media_agents)]

    def total_discordant_messages(self):
        total_discordant_msgs = 0
        for a in self.agents:
            total_discordant_msgs += len(a.discordant_msgs)
        return total_discordant_msgs
   
    # #この時のGからはメディアのノードを削除しなければならない
    # def is_stationary_state(self, G, num_agents, num_media_agents):
    #   media_list = [j+num_agents for j in range(num_media_agents)]
    #   R = G.copy()
    #   R.remove_nodes_from(media_list)
    #   num_clusters = len([R.subgraph(c) for c in nx.weakly_connected_components(R)])
    #   num_coverged_clusters = 0

    #   if num_clusters >= 2:
    #       print(len([R.subgraph(c) for c in nx.weakly_connected_components(R)]))
    #       for C in [R.subgraph(c) for c in nx.weakly_connected_components(R)]:
    #           _agents = [self.agents[i] for i in list(C.nodes())]
    #           opinions = np.array([a.opinion for a in _agents])
    #           opi_diff = np.max(opinions) - np.min(opinions)
    #           if opi_diff <= self.epsilon:
    #               num_coverged_clusters += 1
    #   if num_coverged_clusters == num_clusters:
    #       return True
    #   else:
    #       return False

    def export_csv(self, data_dic, ofname):
        dir_path = os.path.join(self.data_dir, 'data')
        file_path = os.path.join(dir_path, ofname)
        pd.DataFrame(data_dic).to_csv(file_path, compression='xz')

########################################################################################

    #この関数はオリジナルのものと違いgexf形式ではなくcsv形式で出力する。
    def export_csv_new(self, data_dic, ofname):
        dir_path = os.path.join(self.data_dir, 'data')
        #ofnameは引数として渡されるが、その例としてopinions.csv.xz, screen_diversituy.csv.xz, messages.csv.xzなどがある
        file_path = os.path.join(dir_path, ofname)
        #データフレームにcsvファイルの内容を格納する
        pd.DataFrame(data_dic).to_csv(file_path)
    
    #この関数はオリジナルのものとそこまで違わない
    def export_gexf_new(self, t):
      network_dir_path = os.path.join(self.data_dir, "network_data")
      file_path2 = os.path.join(network_dir_path, "G_" + str(t).zfill(7) + ".gexf")
      cls = [float(a.opinion) for a in self.agents] + [float(b.media_opinion) for b in self.media]
      self.social_media.set_node_colors(cls)
      nx.write_gexf(self.social_media.G, file_path2)

########################################################################################

    def final_exports(self, t, num_agents, num_media_agents):

        #ファイルの作成は必要ないので#
        # self.export_csv_new(self.opinion_data, "opinions_new.csv")
        # self.export_csv_new(self.screen_diversity_data, "screen_diversity_new.csv")
        # self.social_media.message_df.to_csv(os.path.join(self.data_dir + '/data', 'messages.csv'))
        # self.export_gexf_new(t)
        df_opinion = pd.DataFrame(self.opinion_data)
        df_media_opinion = pd.DataFrame(self.opinion_media_data)
        # media_list = [j+num_agents for j in range(num_media_agents)]
        # new_df_opinion = df_opinion.drop(media_list, axis = 1)
        df_screen = pd.DataFrame(self.screen_diversity_data)
        return df_opinion, df_screen, df_media_opinion

########################################################################################
########################################################################################

    def evolve(self, t_max, mu, p, q, rewiring_methods, b, c, f, change_methods, num_agents, num_media_agents, delta, omega):
        for t in range(t_max):
          if t in [t_max/5, 2*t_max/5, 3*t_max/5, 4*t_max/5]:
            print("/", end = "")
          if np.random.random() > f:
            self.opinion_data.append([a.opinion for a in self.agents])
            self.screen_diversity_data.append([a.screen_diversity for a in self.agents])
            self.opinion_media_data.append([b.media_opinion for b in self.medias])

            #ファイルの作成は必要ないので#
            # if t % 10000 == 0:
                # self.export_gexf_new(t)

            if extended_model:
              total = 0
              for i in self.opinion_data[-1]:
                total += abs(i)+b
              new_list = [abs(i)+b for i in self.opinion_data[-1]]
              num = random.uniform(0, total)
              total_new = 0
              count = 0
              for i in new_list:
                total_new += i
                count += 1
                if total_new >= num:
                  break
              user_id = count-1
            
            else:
              user_id = np.random.choice(self.num_agents)
             # select agent i at random
             #ランダムに一人のエージェントを選択する

            #agent i refleshes its screen and reading it
            #show_screen関数の戻り値はスクリーン文に相当するメッセージのデータ（データフレーム）
            screen = self.social_media.show_screen(user_id)
            #evaluate_messages関数の戻り値はエージェントが既にメッセージを一件以上受け取っている時に、、
            #self.concordant_msgsとself.dicordant_masgsのリストを作成してメッセージを格納する
            self.agents[user_id].evaluate_messages(screen)
            # self.agents[user_id].screen_diversity = analysis.screen_diversity(screen.content.values, bins=10)
            #そのユーザーのスクリーンに映るメッセージの情報エントロピーを取得
            self.agents[user_id].screen_diversity = screen_diversity(screen.content.values, bins=10)

            # social influence (mu)
            unfollow_id = None
            follow_id = None
            #ここでself.opinionの値が更新される
            self.agents[user_id].update_opinion(mu)

            #rewiring (q)
            if np.random.random() < q:
                #decide_to_rewireはスクリーンに自分の意見と離れているメッセージがある場合、三つの方法でunfollow_idとfollow_idを選んで戻り値とする
                unfollow_id, follow_id = self.agents[user_id].decide_to_rewire(self.social_media, rewiring_methods, num_media_agents)
                if unfollow_id is not None and follow_id is not None:
                    #rewire_userはuser_id,unfollow_id,follow_idの三つの引数によりユーザーとunfollow_idのユーザーのエッジ切って、follow_idのユーザーとエッジを繋ぐ
                    self.social_media.rewire_users(user_id, unfollow_id, follow_id)

            #post (1-p) or repost (p) a message 
            #確率pでリツイートをして戻り値はメッセージ一件、確率1-pで新しいメッセージ一件を作成する
            msg = self.agents[user_id].post_message(t, p)
            #上のコードで作成されたメッセージを全体のメッセージのデータフレームに追加する
            self.social_media.update_message_db(t, msg)
       
            # finalize and export data
            #試行最大数に達するか、意見の分断が十分に起きたらシミュレーションを終了する。
            # if self.is_stationary_state(self.social_media.G, num_agents, num_media_agents):
                # df_opinion, df_screen = self.final_exports(t)
                # return df_opinion, df_screen
                # print(t)

                # break
            if t >= t_max - 1:
                df_opinion, df_screen, df_media_opinion = self.final_exports(t, num_agents, num_media_agents)
                return df_opinion, df_screen, df_media_opinion, self.social_media.G
                break
       
#############################################
        
          else:
            self.opinion_data.append([a.opinion for a in self.agents])
            self.screen_diversity_data.append([a.screen_diversity for a in self.agents])
            self.opinion_media_data.append([b.media_opinion for b in self.medias])

            if extended_media_model:
              total = 0
              for i in d.opinion_media_data[-1]:
                 total += abs(i)+c
              new_list = [abs(i)+c for i in d.opinion_media_data[-1]]
              num = random.uniform(0, total)
              total_new = 0
              count = 0
              for i in new_list:
                total_new += i
                count += 1
                if total_new >= num:
                  break
              user_id = count + num_agents -1

            else:
              media_list = [j+num_agents for j in range(num_media_agents)]
              user_id = np.random.choice(media_list)
            # select agent i at random
            #ランダムに一人のエージェントを選択する

            unfollow_id = None
            follow_id = None

            agents_id = self.medias[user_id - num_agents].evaluate_follower_new(self.social_media, self.opinion_data, change_methods, delta)
            self.medias[user_id - self.num_agents].update_media_opinion(self.opinion_data, omega, agents_id)

            msg = self.medias[user_id - self.num_agents].post_media_messages(t)
            #上のコードで作成されたメッセージを全体のメッセージのデータフレームに追加する
            self.social_media.update_message_db(t, msg)

            # finalize and export data
            #試行最大数に達するか、意見の分断が十分に起きたらシミュレーションを終了する。
            # T = self.social_media.G.copy()
            # E = nx.intersection(self.social_media.G, T)
            # if self.is_stationary_state(E):
            #     df_opinion, df_screen = self.final_exports(t)
            #     return df_opinion, df_screen
            #     print(t)

            #     break
            if t >= t_max - 1:
                df_opinion, df_screen, df_media_opinion = self.final_exports(t, num_agents, num_media_agents)
                return df_opinion, df_screen, df_media_opinion, self.social_media.G
                break

# omega

num_agents = 100
num_links = 400

num_media_agents = 3
num_media_links = 120
#n_media_links/n_media_linksは整数になるべき
sns_seed = 1
l = 10 # screen size
t_max = 10000 # max steps
epsilon = 0.4 # bounded confidence parameter
mu = 0.5 # social influence strength
p = 0.5 # repost rate
q = 0.5 # rewiring rate
extended_model = True
extended_media_model = True
b = 0.1 # rate of selectable agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
c = 0.1 # rate of selectable media agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
# メディアをなくしたければf=0
f = 0.05 # media post rate
delta = 0.1 # bounded confidence parameter for media agents
# omega = 0.2 # influence strength for media
a = "none"
#opinion_listの要素数はnum_media_agentsと一致する
# opinion_list = [-0.6, -0.2, 0.2, 0.6]
opinion_list = [-2/3, 0, 2/3]

method = 2
if method == 1:
  following_methods = ['Random']
elif method == 2:
  following_methods = ['Repost']
elif method == 3:
  following_methods = ['Recommendation']

media_method = 2
if media_method == 1:
  change_methods = "neighbor"
elif media_method == 2:
  change_methods = "opinion_poll"

size = [200]*num_agents + [1000]*num_media_agents

def draw_h(G, pos, measures, size, list_mode, num_agents, num_media_agents):
  if list_mode:
    result = [measures.iloc[-1, i] for i in range(G.number_of_nodes())]
    dict_measure = nx.degree_centrality(G)
    result2 = list(dict_measure.keys())
    vmin_t = -1.0
    vmax_t = 1.0
  else:
    result = measures
    result2 = [i for i in range(num_agents+num_media_agents)]
    # result = list(measures.values())
    # result2 = list(measures.keys())
    vmin_t = 0.0
    vmax_t = 60.0
  nodes = nx.draw_networkx_nodes(G, pos, node_size = size,
                                 cmap = plt.cm.plasma,                   #matplotlibのcolormapを入力
                                 node_color = result,
                                 nodelist = result2)     #posは辞書型、list(measures.values())で辞書のインデックスの方をリストに格納リストに格納
  nodes.set_norm(mcolors.SymLogNorm(linthresh = 0.1, linscale = 1, vmin = vmin_t, vmax = vmax_t))   #?
  # labels = nx.draw_networkx_labels(G, pos)
  edges = nx.draw_networkx_edges(G, pos)                               #エッジを出力
  plt.colorbar(nodes)                                                #カラーバーを出力

##########################################################################################################################################################

i = 0
plt.figure(figsize=(32,22))
for omega in range(0, 101, 25):
  i += 1
  omega = omega / 100
  # now_str = pd.datetime.now().strftime('%Y%m%d%H%M%S')
  # data_root_dir = os.path.join('data_'+''.join(now_str))
  data_root_dir = "none"
  s = datetime.datetime.now()
  d = EchoChamberDynamics(num_agents, num_media_agents, num_links, num_media_links, epsilon, sns_seed, l, data_root_dir, opinion_list)
  df_opinion, df_screen, df_media_opinion, graph = d.evolve(t_max, mu, p, q, following_methods, b, c, f, change_methods, num_agents, num_media_agents, delta, omega)
  # color_list = [e.opinion for e in d.agents] + [g.media_opinion for g in d.medias]
  e = datetime.datetime.now()
  print("  {0}/{1}".format(i, 5), "Computation Time：", e - s)
  if i == 1:
    first = s
  if i == 5:
    print("Total Computation Time", e - first)

  plt.subplot(6, 5, 5*i-4)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("agents omega = {0}".format(omega))
  plt.plot(df_opinion)

  plt.subplot(6, 5, 5*i-3)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("media omega = {0}".format(omega))
  plt.plot(df_media_opinion)

  plt.subplot(6, 5, 5*i-2)
  plt.tight_layout()
  plt.title("opinion_graph")
  df_new = pd.concat([df_opinion, df_media_opinion], axis='columns', ignore_index=True)
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, df_new, size, True, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i-1)
  plt.tight_layout()
  plt.title("in_degree_graph")
  list_new = [i[1] for i in graph.in_degree()]
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, list_new, size, False, num_agents, num_media_agents)
  # draw_h(graph, pos, graph.in_degree_centrality(), size, False, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i)
  hist_list = [i[1] for i in graph.in_degree()]
  plt.ylim(0,80)
  plt.title("in_degree histogram")
  plt.hist(hist_list, range=(0, 60), bins = [2*i for i in range(0, 31)], color='#0000CD')
dt = datetime.datetime.today()
print(dt)
plt.tight_layout(rect=[0,0,1,0.92])
plt.suptitle("\n num_agents={0}, num_links={1}, num_media_agents={2}, num_media_links={3}, screen_size={4}, t_max={5}, epsilon={6}, mu={7}, p={8}, q={9}, \n extended_model={10}, extended_media_model={11}, b={12}, c={13}, f={14}, delta={15}, omega={16}, agent_method={17}, media_method={18}".
             format(num_agents, num_links, num_media_agents, num_media_links, l, t_max, epsilon, mu, p, q, extended_model, extended_media_model, b, c, f, delta, a, following_methods, change_methods)
,fontsize=22)

# omega

num_agents = 100
num_links = 400

num_media_agents = 3
num_media_links = 120
#n_media_links/n_media_linksは整数になるべき
sns_seed = 1
l = 10 # screen size
t_max = 10000 # max steps
epsilon = 0.4 # bounded confidence parameter
mu = 0.5 # social influence strength
p = 0.5 # repost rate
q = 0.5 # rewiring rate
extended_model = True
extended_media_model = True
b = 0.1 # rate of selectable agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
c = 0.1 # rate of selectable media agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
# メディアをなくしたければf=0
f = 0.05 # media post rate
delta = 0.2 # bounded confidence parameter for media agents
# omega = 0.2 # influence strength for media
a = "none"
#opinion_listの要素数はnum_media_agentsと一致する
opinion_list = [-2/3, 0, 2/3]

method = 2
if method == 1:
  following_methods = ['Random']
elif method == 2:
  following_methods = ['Repost']
elif method == 3:
  following_methods = ['Recommendation']

media_method = 2
if media_method == 1:
  change_methods = "neighbor"
elif media_method == 2:
  change_methods = "opinion_poll"

size = [200]*num_agents + [1000]*num_media_agents

def draw_h(G, pos, measures, size, list_mode, num_agents, num_media_agents):
  if list_mode:
    result = [measures.iloc[-1, i] for i in range(G.number_of_nodes())]
    dict_measure = nx.degree_centrality(G)
    result2 = list(dict_measure.keys())
    vmin_t = -1.0
    vmax_t = 1.0
  else:
    result = measures
    result2 = [i for i in range(num_agents+num_media_agents)]
    # result = list(measures.values())
    # result2 = list(measures.keys())
    vmin_t = 0.0
    vmax_t = 60.0
  nodes = nx.draw_networkx_nodes(G, pos, node_size = size,
                                 cmap = plt.cm.plasma,                   #matplotlibのcolormapを入力
                                 node_color = result,
                                 nodelist = result2)     #posは辞書型、list(measures.values())で辞書のインデックスの方をリストに格納リストに格納
  nodes.set_norm(mcolors.SymLogNorm(linthresh = 0.1, linscale = 1, vmin = vmin_t, vmax = vmax_t))   #?
  # labels = nx.draw_networkx_labels(G, pos)
  edges = nx.draw_networkx_edges(G, pos)                               #エッジを出力
  plt.colorbar(nodes)                                                #カラーバーを出力

##########################################################################################################################################################

i = 0
plt.figure(figsize=(32,22))
for omega in range(0, 101, 25):
  i += 1
  omega = omega / 100
  # now_str = pd.datetime.now().strftime('%Y%m%d%H%M%S')
  # data_root_dir = os.path.join('data_'+''.join(now_str))
  data_root_dir = "none"
  s = datetime.datetime.now()
  d = EchoChamberDynamics(num_agents, num_media_agents, num_links, num_media_links, epsilon, sns_seed, l, data_root_dir, opinion_list)
  df_opinion, df_screen, df_media_opinion, graph = d.evolve(t_max, mu, p, q, following_methods, b, c, f, change_methods, num_agents, num_media_agents, delta, omega)
  # color_list = [e.opinion for e in d.agents] + [g.media_opinion for g in d.medias]
  e = datetime.datetime.now()
  print("  {0}/{1}".format(i, 5), "Computation Time：", e - s)
  if i == 1:
    first = s
  if i == 5:
    print("Total Computation Time", e - first)

  plt.subplot(6, 5, 5*i-4)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("agents omega = {0}".format(omega))
  plt.plot(df_opinion)

  plt.subplot(6, 5, 5*i-3)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("media omega = {0}".format(omega))
  plt.plot(df_media_opinion)

  plt.subplot(6, 5, 5*i-2)
  plt.tight_layout()
  plt.title("opinion_graph")
  df_new = pd.concat([df_opinion, df_media_opinion], axis='columns', ignore_index=True)
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, df_new, size, True, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i-1)
  plt.tight_layout()
  plt.title("in_degree_graph")
  list_new = [i[1] for i in graph.in_degree()]
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, list_new, size, False, num_agents, num_media_agents)
  # draw_h(graph, pos, graph.in_degree_centrality(), size, False, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i)
  hist_list = [i[1] for i in graph.in_degree()]
  plt.ylim(0,80)
  plt.title("in_degree histogram")
  plt.hist(hist_list, range=(0, 60), bins = [2*i for i in range(0, 31)], color='#0000CD')

dt = datetime.datetime.today()
print(dt)
plt.tight_layout(rect=[0,0,1,0.92])
plt.suptitle("\n num_agents={0}, num_links={1}, num_media_agents={2}, num_media_links={3}, screen_size={4}, t_max={5}, epsilon={6}, mu={7}, p={8}, q={9}, \n extended_model={10}, extended_media_model={11}, b={12}, c={13}, f={14}, delta={15}, omega={16}, agent_method={17}, media_method={18}".
             format(num_agents, num_links, num_media_agents, num_media_links, l, t_max, epsilon, mu, p, q, extended_model, extended_media_model, b, c, f, delta, a, following_methods, change_methods)
,fontsize=22)

# omega

num_agents = 100
num_links = 400

num_media_agents = 3
num_media_links = 120
#n_media_links/n_media_linksは整数になるべき
sns_seed = 1
l = 10 # screen size
t_max = 10000 # max steps
epsilon = 0.4 # bounded confidence parameter
mu = 0.5 # social influence strength
p = 0.5 # repost rate
q = 0.5 # rewiring rate
extended_model = True
extended_media_model = True
b = 0.1 # rate of selectable agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
c = 0.1 # rate of selectable media agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
# メディアをなくしたければf=0
f = 0.05 # media post rate
delta = 0.4 # bounded confidence parameter for media agents
# omega = 0.2 # influence strength for media
a = "none"
#opinion_listの要素数はnum_media_agentsと一致する
opinion_list = [-2/3, 0, 2/3]

method = 2
if method == 1:
  following_methods = ['Random']
elif method == 2:
  following_methods = ['Repost']
elif method == 3:
  following_methods = ['Recommendation']

media_method = 2
if media_method == 1:
  change_methods = "neighbor"
elif media_method == 2:
  change_methods = "opinion_poll"

size = [200]*num_agents + [1000]*num_media_agents

def draw_h(G, pos, measures, size, list_mode, num_agents, num_media_agents):
  if list_mode:
    result = [measures.iloc[-1, i] for i in range(G.number_of_nodes())]
    dict_measure = nx.degree_centrality(G)
    result2 = list(dict_measure.keys())
    vmin_t = -1.0
    vmax_t = 1.0
  else:
    result = measures
    result2 = [i for i in range(num_agents+num_media_agents)]
    # result = list(measures.values())
    # result2 = list(measures.keys())
    vmin_t = 0.0
    vmax_t = 60.0
  nodes = nx.draw_networkx_nodes(G, pos, node_size = size,
                                 cmap = plt.cm.plasma,                   #matplotlibのcolormapを入力
                                 node_color = result,
                                 nodelist = result2)     #posは辞書型、list(measures.values())で辞書のインデックスの方をリストに格納リストに格納
  nodes.set_norm(mcolors.SymLogNorm(linthresh = 0.1, linscale = 1, vmin = vmin_t, vmax = vmax_t))   #?
  # labels = nx.draw_networkx_labels(G, pos)
  edges = nx.draw_networkx_edges(G, pos)                               #エッジを出力
  plt.colorbar(nodes)                                                #カラーバーを出力

##########################################################################################################################################################

i = 0
plt.figure(figsize=(32,22))
for omega in range(0, 101, 25):
  i += 1
  omega = omega / 100
  # now_str = pd.datetime.now().strftime('%Y%m%d%H%M%S')
  # data_root_dir = os.path.join('data_'+''.join(now_str))
  data_root_dir = "none"
  s = datetime.datetime.now()
  d = EchoChamberDynamics(num_agents, num_media_agents, num_links, num_media_links, epsilon, sns_seed, l, data_root_dir, opinion_list)
  df_opinion, df_screen, df_media_opinion, graph = d.evolve(t_max, mu, p, q, following_methods, b, c, f, change_methods, num_agents, num_media_agents, delta, omega)
  # color_list = [e.opinion for e in d.agents] + [g.media_opinion for g in d.medias]
  e = datetime.datetime.now()
  print("  {0}/{1}".format(i, 5), "Computation Time：", e - s)
  if i == 1:
    first = s
  if i == 5:
    print("Total Computation Time", e - first)

  plt.subplot(6, 5, 5*i-4)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("agents omega = {0}".format(omega))
  plt.plot(df_opinion)

  plt.subplot(6, 5, 5*i-3)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("media omega = {0}".format(omega))
  plt.plot(df_media_opinion)

  plt.subplot(6, 5, 5*i-2)
  plt.tight_layout()
  plt.title("opinion_graph")
  df_new = pd.concat([df_opinion, df_media_opinion], axis='columns', ignore_index=True)
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, df_new, size, True, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i-1)
  plt.tight_layout()
  plt.title("in_degree_graph")
  list_new = [i[1] for i in graph.in_degree()]
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, list_new, size, False, num_agents, num_media_agents)
  # draw_h(graph, pos, graph.in_degree_centrality(), size, False, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i)
  hist_list = [i[1] for i in graph.in_degree()]
  plt.ylim(0,80)
  plt.title("in_degree histogram")
  plt.hist(hist_list, range=(0, 60), bins = [2*i for i in range(0, 31)], color='#0000CD')

dt = datetime.datetime.today()
print(dt)
plt.tight_layout(rect=[0,0,1,0.92])
plt.suptitle("\n num_agents={0}, num_links={1}, num_media_agents={2}, num_media_links={3}, screen_size={4}, t_max={5}, epsilon={6}, mu={7}, p={8}, q={9}, \n extended_model={10}, extended_media_model={11}, b={12}, c={13}, f={14}, delta={15}, omega={16}, agent_method={17}, media_method={18}".
             format(num_agents, num_links, num_media_agents, num_media_links, l, t_max, epsilon, mu, p, q, extended_model, extended_media_model, b, c, f, delta, a, following_methods, change_methods)
,fontsize=22)

# omega

num_agents = 100
num_links = 400

num_media_agents = 3
num_media_links = 120
#n_media_links/n_media_linksは整数になるべき
sns_seed = 1
l = 10 # screen size
t_max = 10000 # max steps
epsilon = 0.4 # bounded confidence parameter
mu = 0.5 # social influence strength
p = 0.5 # repost rate
q = 0.5 # rewiring rate
extended_model = True
extended_media_model = True
b = 0.1 # rate of selectable agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
c = 0.1 # rate of selectable media agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
# メディアをなくしたければf=0
f = 0.05 # media post rate
delta = 0.8 # bounded confidence parameter for media agents
# omega = 0.2 # influence strength for media
a = "none"
#opinion_listの要素数はnum_media_agentsと一致する
opinion_list = [-2/3, 0, 2/3]

method = 2
if method == 1:
  following_methods = ['Random']
elif method == 2:
  following_methods = ['Repost']
elif method == 3:
  following_methods = ['Recommendation']

media_method = 2
if media_method == 1:
  change_methods = "neighbor"
elif media_method == 2:
  change_methods = "opinion_poll"

size = [200]*num_agents + [1000]*num_media_agents

def draw_h(G, pos, measures, size, list_mode, num_agents, num_media_agents):
  if list_mode:
    result = [measures.iloc[-1, i] for i in range(G.number_of_nodes())]
    dict_measure = nx.degree_centrality(G)
    result2 = list(dict_measure.keys())
    vmin_t = -1.0
    vmax_t = 1.0
  else:
    result = measures
    result2 = [i for i in range(num_agents+num_media_agents)]
    # result = list(measures.values())
    # result2 = list(measures.keys())
    vmin_t = 0.0
    vmax_t = 60.0
  nodes = nx.draw_networkx_nodes(G, pos, node_size = size,
                                 cmap = plt.cm.plasma,                   #matplotlibのcolormapを入力
                                 node_color = result,
                                 nodelist = result2)     #posは辞書型、list(measures.values())で辞書のインデックスの方をリストに格納リストに格納
  nodes.set_norm(mcolors.SymLogNorm(linthresh = 0.1, linscale = 1, vmin = vmin_t, vmax = vmax_t))   #?
  # labels = nx.draw_networkx_labels(G, pos)
  edges = nx.draw_networkx_edges(G, pos)                               #エッジを出力
  plt.colorbar(nodes)                                                #カラーバーを出力

##########################################################################################################################################################

i = 0
plt.figure(figsize=(32,22))
for omega in range(0, 101, 25):
  i += 1
  omega = omega / 100
  # now_str = pd.datetime.now().strftime('%Y%m%d%H%M%S')
  # data_root_dir = os.path.join('data_'+''.join(now_str))
  data_root_dir = "none"
  s = datetime.datetime.now()
  d = EchoChamberDynamics(num_agents, num_media_agents, num_links, num_media_links, epsilon, sns_seed, l, data_root_dir, opinion_list)
  df_opinion, df_screen, df_media_opinion, graph = d.evolve(t_max, mu, p, q, following_methods, b, c, f, change_methods, num_agents, num_media_agents, delta, omega)
  # color_list = [e.opinion for e in d.agents] + [g.media_opinion for g in d.medias]
  e = datetime.datetime.now()
  print("  {0}/{1}".format(i, 5), "Computation Time：", e - s)
  if i == 1:
    first = s
  if i == 5:
    print("Total Computation Time", e - first)

  plt.subplot(6, 5, 5*i-4)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("agents omega = {0}".format(omega))
  plt.plot(df_opinion)

  plt.subplot(6, 5, 5*i-3)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("media omega = {0}".format(omega))
  plt.plot(df_media_opinion)

  plt.subplot(6, 5, 5*i-2)
  plt.tight_layout()
  plt.title("opinion_graph")
  df_new = pd.concat([df_opinion, df_media_opinion], axis='columns', ignore_index=True)
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, df_new, size, True, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i-1)
  plt.tight_layout()
  plt.title("in_degree_graph")
  list_new = [i[1] for i in graph.in_degree()]
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, list_new, size, False, num_agents, num_media_agents)
  # draw_h(graph, pos, graph.in_degree_centrality(), size, False, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i)
  hist_list = [i[1] for i in graph.in_degree()]
  plt.ylim(0,80)
  plt.title("in_degree histogram")
  plt.hist(hist_list, range=(0, 60), bins = [2*i for i in range(0, 31)], color='#0000CD')

dt = datetime.datetime.today()
print(dt)
plt.tight_layout(rect=[0,0,1,0.92])
plt.suptitle("\n num_agents={0}, num_links={1}, num_media_agents={2}, num_media_links={3}, screen_size={4}, t_max={5}, epsilon={6}, mu={7}, p={8}, q={9}, \n extended_model={10}, extended_media_model={11}, b={12}, c={13}, f={14}, delta={15}, omega={16}, agent_method={17}, media_method={18}".
             format(num_agents, num_links, num_media_agents, num_media_links, l, t_max, epsilon, mu, p, q, extended_model, extended_media_model, b, c, f, delta, a, following_methods, change_methods)
,fontsize=22)



# omega

num_agents = 100
num_links = 400

num_media_agents = 3
num_media_links = 120
#n_media_links/n_media_linksは整数になるべき
sns_seed = 1
l = 10 # screen size
t_max = 10000 # max steps
epsilon = 0.4 # bounded confidence parameter
mu = 0.5 # social influence strength
p = 0.5 # repost rate
q = 0.5 # rewiring rate
extended_model = True
extended_media_model = False
b = 0.1 # rate of selectable agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
c = 0.1 # rate of selectable media agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
# メディアをなくしたければf=0
f = 0.05 # media post rate
delta = 0.1 # bounded confidence parameter for media agents
# omega = 0.2 # influence strength for media
a = "none"
#opinion_listの要素数はnum_media_agentsと一致する
opinion_list = [-2/3, 0, 2/3]

method = 2
if method == 1:
  following_methods = ['Random']
elif method == 2:
  following_methods = ['Repost']
elif method == 3:
  following_methods = ['Recommendation']

media_method = 2
if media_method == 1:
  change_methods = "neighbor"
elif media_method == 2:
  change_methods = "opinion_poll"

size = [200]*num_agents + [1000]*num_media_agents

def draw_h(G, pos, measures, size, list_mode, num_agents, num_media_agents):
  if list_mode:
    result = [measures.iloc[-1, i] for i in range(G.number_of_nodes())]
    dict_measure = nx.degree_centrality(G)
    result2 = list(dict_measure.keys())
    vmin_t = -1.0
    vmax_t = 1.0
  else:
    result = measures
    result2 = [i for i in range(num_agents+num_media_agents)]
    # result = list(measures.values())
    # result2 = list(measures.keys())
    vmin_t = 0.0
    vmax_t = 60.0
  nodes = nx.draw_networkx_nodes(G, pos, node_size = size,
                                 cmap = plt.cm.plasma,                   #matplotlibのcolormapを入力
                                 node_color = result,
                                 nodelist = result2)     #posは辞書型、list(measures.values())で辞書のインデックスの方をリストに格納リストに格納
  nodes.set_norm(mcolors.SymLogNorm(linthresh = 0.1, linscale = 1, vmin = vmin_t, vmax = vmax_t))   #?
  # labels = nx.draw_networkx_labels(G, pos)
  edges = nx.draw_networkx_edges(G, pos)                               #エッジを出力
  plt.colorbar(nodes)                                                #カラーバーを出力

##########################################################################################################################################################

i = 0
plt.figure(figsize=(32,22))
for omega in range(0, 101, 25):
  i += 1
  omega = omega / 100
  # now_str = pd.datetime.now().strftime('%Y%m%d%H%M%S')
  # data_root_dir = os.path.join('data_'+''.join(now_str))
  data_root_dir = "none"
  s = datetime.datetime.now()
  d = EchoChamberDynamics(num_agents, num_media_agents, num_links, num_media_links, epsilon, sns_seed, l, data_root_dir, opinion_list)
  df_opinion, df_screen, df_media_opinion, graph = d.evolve(t_max, mu, p, q, following_methods, b, c, f, change_methods, num_agents, num_media_agents, delta, omega)
  # color_list = [e.opinion for e in d.agents] + [g.media_opinion for g in d.medias]
  e = datetime.datetime.now()
  print("  {0}/{1}".format(i, 5), "Computation Time：", e - s)
  if i == 1:
    first = s
  if i == 5:
    print("Total Computation Time", e - first)

  plt.subplot(6, 5, 5*i-4)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("agents omega = {0}".format(omega))
  plt.plot(df_opinion)

  plt.subplot(6, 5, 5*i-3)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("media omega = {0}".format(omega))
  plt.plot(df_media_opinion)

  plt.subplot(6, 5, 5*i-2)
  plt.tight_layout()
  plt.title("opinion_graph")
  df_new = pd.concat([df_opinion, df_media_opinion], axis='columns', ignore_index=True)
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, df_new, size, True, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i-1)
  plt.tight_layout()
  plt.title("in_degree_graph")
  list_new = [i[1] for i in graph.in_degree()]
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, list_new, size, False, num_agents, num_media_agents)
  # draw_h(graph, pos, graph.in_degree_centrality(), size, False, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i)
  hist_list = [i[1] for i in graph.in_degree()]
  plt.ylim(0,80)
  plt.title("in_degree histogram")
  plt.hist(hist_list, range=(0, 60), bins = [2*i for i in range(0, 31)], color='#0000CD')

dt = datetime.datetime.today()
print(dt)
plt.tight_layout(rect=[0,0,1,0.92])
plt.suptitle("\n num_agents={0}, num_links={1}, num_media_agents={2}, num_media_links={3}, screen_size={4}, t_max={5}, epsilon={6}, mu={7}, p={8}, q={9}, \n extended_model={10}, extended_media_model={11}, b={12}, c={13}, f={14}, delta={15}, omega={16}, agent_method={17}, media_method={18}".
             format(num_agents, num_links, num_media_agents, num_media_links, l, t_max, epsilon, mu, p, q, extended_model, extended_media_model, b, c, f, delta, a, following_methods, change_methods)
,fontsize=22)

# omega

num_agents = 100
num_links = 400

num_media_agents = 3
num_media_links = 120
#n_media_links/n_media_linksは整数になるべき
sns_seed = 1
l = 10 # screen size
t_max = 10000 # max steps
epsilon = 0.4 # bounded confidence parameter
mu = 0.5 # social influence strength
p = 0.5 # repost rate
q = 0.5 # rewiring rate
extended_model = True
extended_media_model = False
b = 0.1 # rate of selectable agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
c = 0.1 # rate of selectable media agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
# メディアをなくしたければf=0
f = 0.05 # media post rate
delta = 0.2 # bounded confidence parameter for media agents
# omega = 0.2 # influence strength for media
a = "none"
#opinion_listの要素数はnum_media_agentsと一致する
opinion_list = [-2/3, 0, 2/3]

method = 2
if method == 1:
  following_methods = ['Random']
elif method == 2:
  following_methods = ['Repost']
elif method == 3:
  following_methods = ['Recommendation']

media_method = 2
if media_method == 1:
  change_methods = "neighbor"
elif media_method == 2:
  change_methods = "opinion_poll"

size = [200]*num_agents + [1000]*num_media_agents

def draw_h(G, pos, measures, size, list_mode, num_agents, num_media_agents):
  if list_mode:
    result = [measures.iloc[-1, i] for i in range(G.number_of_nodes())]
    dict_measure = nx.degree_centrality(G)
    result2 = list(dict_measure.keys())
    vmin_t = -1.0
    vmax_t = 1.0
  else:
    result = measures
    result2 = [i for i in range(num_agents+num_media_agents)]
    # result = list(measures.values())
    # result2 = list(measures.keys())
    vmin_t = 0.0
    vmax_t = 60.0
  nodes = nx.draw_networkx_nodes(G, pos, node_size = size,
                                 cmap = plt.cm.plasma,                   #matplotlibのcolormapを入力
                                 node_color = result,
                                 nodelist = result2)     #posは辞書型、list(measures.values())で辞書のインデックスの方をリストに格納リストに格納
  nodes.set_norm(mcolors.SymLogNorm(linthresh = 0.1, linscale = 1, vmin = vmin_t, vmax = vmax_t))   #?
  # labels = nx.draw_networkx_labels(G, pos)
  edges = nx.draw_networkx_edges(G, pos)                               #エッジを出力
  plt.colorbar(nodes)                                                #カラーバーを出力

##########################################################################################################################################################

i = 0
plt.figure(figsize=(32,22))
for omega in range(0, 101, 25):
  i += 1
  omega = omega / 100
  # now_str = pd.datetime.now().strftime('%Y%m%d%H%M%S')
  # data_root_dir = os.path.join('data_'+''.join(now_str))
  data_root_dir = "none"
  s = datetime.datetime.now()
  d = EchoChamberDynamics(num_agents, num_media_agents, num_links, num_media_links, epsilon, sns_seed, l, data_root_dir, opinion_list)
  df_opinion, df_screen, df_media_opinion, graph = d.evolve(t_max, mu, p, q, following_methods, b, c, f, change_methods, num_agents, num_media_agents, delta, omega)
  # color_list = [e.opinion for e in d.agents] + [g.media_opinion for g in d.medias]
  e = datetime.datetime.now()
  print("  {0}/{1}".format(i, 5), "Computation Time：", e - s)
  if i == 1:
    first = s
  if i == 5:
    print("Total Computation Time", e - first)

  plt.subplot(6, 5, 5*i-4)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("agents omega = {0}".format(omega))
  plt.plot(df_opinion)

  plt.subplot(6, 5, 5*i-3)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("media omega = {0}".format(omega))
  plt.plot(df_media_opinion)

  plt.subplot(6, 5, 5*i-2)
  plt.tight_layout()
  plt.title("opinion_graph")
  df_new = pd.concat([df_opinion, df_media_opinion], axis='columns', ignore_index=True)
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, df_new, size, True, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i-1)
  plt.tight_layout()
  plt.title("in_degree_graph")
  list_new = [i[1] for i in graph.in_degree()]
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, list_new, size, False, num_agents, num_media_agents)
  # draw_h(graph, pos, graph.in_degree_centrality(), size, False, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i)
  hist_list = [i[1] for i in graph.in_degree()]
  plt.ylim(0,80)
  plt.title("in_degree histogram")
  plt.hist(hist_list, range=(0, 60), bins = [2*i for i in range(0, 31)], color='#0000CD')

dt = datetime.datetime.today()
print(dt)
plt.tight_layout(rect=[0,0,1,0.92])
plt.suptitle("\n num_agents={0}, num_links={1}, num_media_agents={2}, num_media_links={3}, screen_size={4}, t_max={5}, epsilon={6}, mu={7}, p={8}, q={9}, \n extended_model={10}, extended_media_model={11}, b={12}, c={13}, f={14}, delta={15}, omega={16}, agent_method={17}, media_method={18}".
             format(num_agents, num_links, num_media_agents, num_media_links, l, t_max, epsilon, mu, p, q, extended_model, extended_media_model, b, c, f, delta, a, following_methods, change_methods)
,fontsize=22)

# omega

num_agents = 100
num_links = 400

num_media_agents = 3
num_media_links = 120
#n_media_links/n_media_linksは整数になるべき
sns_seed = 1
l = 10 # screen size
t_max = 10000 # max steps
epsilon = 0.4 # bounded confidence parameter
mu = 0.5 # social influence strength
p = 0.5 # repost rate
q = 0.5 # rewiring rate
extended_model = True
extended_media_model = False
b = 0.1 # rate of selectable agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
c = 0.1 # rate of selectable media agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
# メディアをなくしたければf=0
f = 0.05 # media post rate
delta = 0.4 # bounded confidence parameter for media agents
# omega = 0.2 # influence strength for media
a = "none"
#opinion_listの要素数はnum_media_agentsと一致する
opinion_list = [-2/3, 0, 2/3]

method = 2
if method == 1:
  following_methods = ['Random']
elif method == 2:
  following_methods = ['Repost']
elif method == 3:
  following_methods = ['Recommendation']

media_method = 2
if media_method == 1:
  change_methods = "neighbor"
elif media_method == 2:
  change_methods = "opinion_poll"

size = [200]*num_agents + [1000]*num_media_agents

def draw_h(G, pos, measures, size, list_mode, num_agents, num_media_agents):
  if list_mode:
    result = [measures.iloc[-1, i] for i in range(G.number_of_nodes())]
    dict_measure = nx.degree_centrality(G)
    result2 = list(dict_measure.keys())
    vmin_t = -1.0
    vmax_t = 1.0
  else:
    result = measures
    result2 = [i for i in range(num_agents+num_media_agents)]
    # result = list(measures.values())
    # result2 = list(measures.keys())
    vmin_t = 0.0
    vmax_t = 60.0
  nodes = nx.draw_networkx_nodes(G, pos, node_size = size,
                                 cmap = plt.cm.plasma,                   #matplotlibのcolormapを入力
                                 node_color = result,
                                 nodelist = result2)     #posは辞書型、list(measures.values())で辞書のインデックスの方をリストに格納リストに格納
  nodes.set_norm(mcolors.SymLogNorm(linthresh = 0.1, linscale = 1, vmin = vmin_t, vmax = vmax_t))   #?
  # labels = nx.draw_networkx_labels(G, pos)
  edges = nx.draw_networkx_edges(G, pos)                               #エッジを出力
  plt.colorbar(nodes)                                                #カラーバーを出力

##########################################################################################################################################################

i = 0
plt.figure(figsize=(32,22))
for omega in range(0, 101, 25):
  i += 1
  omega = omega / 100
  # now_str = pd.datetime.now().strftime('%Y%m%d%H%M%S')
  # data_root_dir = os.path.join('data_'+''.join(now_str))
  data_root_dir = "none"
  s = datetime.datetime.now()
  d = EchoChamberDynamics(num_agents, num_media_agents, num_links, num_media_links, epsilon, sns_seed, l, data_root_dir, opinion_list)
  df_opinion, df_screen, df_media_opinion, graph = d.evolve(t_max, mu, p, q, following_methods, b, c, f, change_methods, num_agents, num_media_agents, delta, omega)
  # color_list = [e.opinion for e in d.agents] + [g.media_opinion for g in d.medias]
  e = datetime.datetime.now()
  print("  {0}/{1}".format(i, 5), "Computation Time：", e - s)
  if i == 1:
    first = s
  if i == 5:
    print("Total Computation Time", e - first)

  plt.subplot(6, 5, 5*i-4)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("agents omega = {0}".format(omega))
  plt.plot(df_opinion)

  plt.subplot(6, 5, 5*i-3)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("media omega = {0}".format(omega))
  plt.plot(df_media_opinion)

  plt.subplot(6, 5, 5*i-2)
  plt.tight_layout()
  plt.title("opinion_graph")
  df_new = pd.concat([df_opinion, df_media_opinion], axis='columns', ignore_index=True)
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, df_new, size, True, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i-1)
  plt.tight_layout()
  plt.title("in_degree_graph")
  list_new = [i[1] for i in graph.in_degree()]
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, list_new, size, False, num_agents, num_media_agents)
  # draw_h(graph, pos, graph.in_degree_centrality(), size, False, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i)
  hist_list = [i[1] for i in graph.in_degree()]
  plt.ylim(0,80)
  plt.title("in_degree histogram")
  plt.hist(hist_list, range=(0, 60), bins = [2*i for i in range(0, 31)], color='#0000CD')

dt = datetime.datetime.today()
print(dt)
plt.tight_layout(rect=[0,0,1,0.92])
plt.suptitle("\n num_agents={0}, num_links={1}, num_media_agents={2}, num_media_links={3}, screen_size={4}, t_max={5}, epsilon={6}, mu={7}, p={8}, q={9}, \n extended_model={10}, extended_media_model={11}, b={12}, c={13}, f={14}, delta={15}, omega={16}, agent_method={17}, media_method={18}".
             format(num_agents, num_links, num_media_agents, num_media_links, l, t_max, epsilon, mu, p, q, extended_model, extended_media_model, b, c, f, delta, a, following_methods, change_methods)
,fontsize=22)

# omega

num_agents = 100
num_links = 400

num_media_agents = 3
num_media_links = 120
#n_media_links/n_media_linksは整数になるべき
sns_seed = 1
l = 10 # screen size
t_max = 10000 # max steps
epsilon = 0.4 # bounded confidence parameter
mu = 0.5 # social influence strength
p = 0.5 # repost rate
q = 0.5 # rewiring rate
extended_model = True
extended_media_model = False
b = 0.1 # rate of selectable agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
c = 0.1 # rate of selectable media agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
# メディアをなくしたければf=0
f = 0.05 # media post rate
delta = 0.8 # bounded confidence parameter for media agents
# omega = 0.2 # influence strength for media
a = "none"
#opinion_listの要素数はnum_media_agentsと一致する
opinion_list = [-2/3, 0, 2/3]

method = 2
if method == 1:
  following_methods = ['Random']
elif method == 2:
  following_methods = ['Repost']
elif method == 3:
  following_methods = ['Recommendation']

media_method = 2
if media_method == 1:
  change_methods = "neighbor"
elif media_method == 2:
  change_methods = "opinion_poll"

size = [200]*num_agents + [1000]*num_media_agents

def draw_h(G, pos, measures, size, list_mode, num_agents, num_media_agents):
  if list_mode:
    result = [measures.iloc[-1, i] for i in range(G.number_of_nodes())]
    dict_measure = nx.degree_centrality(G)
    result2 = list(dict_measure.keys())
    vmin_t = -1.0
    vmax_t = 1.0
  else:
    result = measures
    result2 = [i for i in range(num_agents+num_media_agents)]
    # result = list(measures.values())
    # result2 = list(measures.keys())
    vmin_t = 0.0
    vmax_t = 60.0
  nodes = nx.draw_networkx_nodes(G, pos, node_size = size,
                                 cmap = plt.cm.plasma,                   #matplotlibのcolormapを入力
                                 node_color = result,
                                 nodelist = result2)     #posは辞書型、list(measures.values())で辞書のインデックスの方をリストに格納リストに格納
  nodes.set_norm(mcolors.SymLogNorm(linthresh = 0.1, linscale = 1, vmin = vmin_t, vmax = vmax_t))   #?
  # labels = nx.draw_networkx_labels(G, pos)
  edges = nx.draw_networkx_edges(G, pos)                               #エッジを出力
  plt.colorbar(nodes)                                                #カラーバーを出力

##########################################################################################################################################################

i = 0
plt.figure(figsize=(32,22))
for omega in range(0, 101, 25):
  i += 1
  omega = omega / 100
  # now_str = pd.datetime.now().strftime('%Y%m%d%H%M%S')
  # data_root_dir = os.path.join('data_'+''.join(now_str))
  data_root_dir = "none"
  s = datetime.datetime.now()
  d = EchoChamberDynamics(num_agents, num_media_agents, num_links, num_media_links, epsilon, sns_seed, l, data_root_dir, opinion_list)
  df_opinion, df_screen, df_media_opinion, graph = d.evolve(t_max, mu, p, q, following_methods, b, c, f, change_methods, num_agents, num_media_agents, delta, omega)
  # color_list = [e.opinion for e in d.agents] + [g.media_opinion for g in d.medias]
  e = datetime.datetime.now()
  print("  {0}/{1}".format(i, 5), "Computation Time：", e - s)
  if i == 1:
    first = s
  if i == 5:
    print("Total Computation Time", e - first)

  plt.subplot(6, 5, 5*i-4)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("agents omega = {0}".format(omega))
  plt.plot(df_opinion)

  plt.subplot(6, 5, 5*i-3)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("media omega = {0}".format(omega))
  plt.plot(df_media_opinion)

  plt.subplot(6, 5, 5*i-2)
  plt.tight_layout()
  plt.title("opinion_graph")
  df_new = pd.concat([df_opinion, df_media_opinion], axis='columns', ignore_index=True)
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, df_new, size, True, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i-1)
  plt.tight_layout()
  plt.title("in_degree_graph")
  list_new = [i[1] for i in graph.in_degree()]
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, list_new, size, False, num_agents, num_media_agents)
  # draw_h(graph, pos, graph.in_degree_centrality(), size, False, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i)
  hist_list = [i[1] for i in graph.in_degree()]
  plt.ylim(0,80)
  plt.title("in_degree histogram")
  plt.hist(hist_list, range=(0, 60), bins = [2*i for i in range(0, 31)], color='#0000CD')

dt = datetime.datetime.today()
print(dt)
plt.tight_layout(rect=[0,0,1,0.92])
plt.suptitle("\n num_agents={0}, num_links={1}, num_media_agents={2}, num_media_links={3}, screen_size={4}, t_max={5}, epsilon={6}, mu={7}, p={8}, q={9}, \n extended_model={10}, extended_media_model={11}, b={12}, c={13}, f={14}, delta={15}, omega={16}, agent_method={17}, media_method={18}".
             format(num_agents, num_links, num_media_agents, num_media_links, l, t_max, epsilon, mu, p, q, extended_model, extended_media_model, b, c, f, delta, a, following_methods, change_methods)
,fontsize=22)



# omega

num_agents = 100
num_links = 400

num_media_agents = 3
num_media_links = 120
#n_media_links/n_media_linksは整数になるべき
sns_seed = 1
l = 10 # screen size
t_max = 10000 # max steps
epsilon = 0.4 # bounded confidence parameter
mu = 0.5 # social influence strength
p = 0.5 # repost rate
q = 0.5 # rewiring rate
extended_model = False
extended_media_model = False
b = 0.1 # rate of selectable agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
c = 0.1 # rate of selectable media agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
# メディアをなくしたければf=0
f = 0.05 # media post rate
delta = 0.1 # bounded confidence parameter for media agents
# omega = 0.2 # influence strength for media
a = "none"
#opinion_listの要素数はnum_media_agentsと一致する
opinion_list = [-2/3, 0, 2/3]

method = 2
if method == 1:
  following_methods = ['Random']
elif method == 2:
  following_methods = ['Repost']
elif method == 3:
  following_methods = ['Recommendation']

media_method = 2
if media_method == 1:
  change_methods = "neighbor"
elif media_method == 2:
  change_methods = "opinion_poll"

size = [200]*num_agents + [1000]*num_media_agents

def draw_h(G, pos, measures, size, list_mode, num_agents, num_media_agents):
  if list_mode:
    result = [measures.iloc[-1, i] for i in range(G.number_of_nodes())]
    dict_measure = nx.degree_centrality(G)
    result2 = list(dict_measure.keys())
    vmin_t = -1.0
    vmax_t = 1.0
  else:
    result = measures
    result2 = [i for i in range(num_agents+num_media_agents)]
    # result = list(measures.values())
    # result2 = list(measures.keys())
    vmin_t = 0.0
    vmax_t = 60.0
  nodes = nx.draw_networkx_nodes(G, pos, node_size = size,
                                 cmap = plt.cm.plasma,                   #matplotlibのcolormapを入力
                                 node_color = result,
                                 nodelist = result2)     #posは辞書型、list(measures.values())で辞書のインデックスの方をリストに格納リストに格納
  nodes.set_norm(mcolors.SymLogNorm(linthresh = 0.1, linscale = 1, vmin = vmin_t, vmax = vmax_t))   #?
  # labels = nx.draw_networkx_labels(G, pos)
  edges = nx.draw_networkx_edges(G, pos)                               #エッジを出力
  plt.colorbar(nodes)                                                #カラーバーを出力

##########################################################################################################################################################

i = 0
plt.figure(figsize=(32,22))
for omega in range(0, 101, 25):
  i += 1
  omega = omega / 100
  # now_str = pd.datetime.now().strftime('%Y%m%d%H%M%S')
  # data_root_dir = os.path.join('data_'+''.join(now_str))
  data_root_dir = "none"
  s = datetime.datetime.now()
  d = EchoChamberDynamics(num_agents, num_media_agents, num_links, num_media_links, epsilon, sns_seed, l, data_root_dir, opinion_list)
  df_opinion, df_screen, df_media_opinion, graph = d.evolve(t_max, mu, p, q, following_methods, b, c, f, change_methods, num_agents, num_media_agents, delta, omega)
  # color_list = [e.opinion for e in d.agents] + [g.media_opinion for g in d.medias]
  e = datetime.datetime.now()
  print("  {0}/{1}".format(i, 5), "Computation Time：", e - s)
  if i == 1:
    first = s
  if i == 5:
    print("Total Computation Time", e - first)

  plt.subplot(6, 5, 5*i-4)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("agents omega = {0}".format(omega))
  plt.plot(df_opinion)

  plt.subplot(6, 5, 5*i-3)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("media omega = {0}".format(omega))
  plt.plot(df_media_opinion)

  plt.subplot(6, 5, 5*i-2)
  plt.tight_layout()
  plt.title("opinion_graph")
  df_new = pd.concat([df_opinion, df_media_opinion], axis='columns', ignore_index=True)
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, df_new, size, True, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i-1)
  plt.tight_layout()
  plt.title("in_degree_graph")
  list_new = [i[1] for i in graph.in_degree()]
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, list_new, size, False, num_agents, num_media_agents)
  # draw_h(graph, pos, graph.in_degree_centrality(), size, False, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i)
  hist_list = [i[1] for i in graph.in_degree()]
  plt.ylim(0,80)
  plt.title("in_degree histogram")
  plt.hist(hist_list, range=(0, 60), bins = [2*i for i in range(0, 31)], color='#0000CD')

dt = datetime.datetime.today()
print(dt)
plt.tight_layout(rect=[0,0,1,0.92])
plt.suptitle("\n num_agents={0}, num_links={1}, num_media_agents={2}, num_media_links={3}, screen_size={4}, t_max={5}, epsilon={6}, mu={7}, p={8}, q={9}, \n extended_model={10}, extended_media_model={11}, b={12}, c={13}, f={14}, delta={15}, omega={16}, agent_method={17}, media_method={18}".
             format(num_agents, num_links, num_media_agents, num_media_links, l, t_max, epsilon, mu, p, q, extended_model, extended_media_model, b, c, f, delta, a, following_methods, change_methods)
,fontsize=22)

# omega

num_agents = 100
num_links = 400

num_media_agents = 3
num_media_links = 120
#n_media_links/n_media_linksは整数になるべき
sns_seed = 1
l = 10 # screen size
t_max = 10000 # max steps
epsilon = 0.4 # bounded confidence parameter
mu = 0.5 # social influence strength
p = 0.5 # repost rate
q = 0.5 # rewiring rate
extended_model = False
extended_media_model = False
b = 0.1 # rate of selectable agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
c = 0.1 # rate of selectable media agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
# メディアをなくしたければf=0
f = 0.05 # media post rate
delta = 0.2 # bounded confidence parameter for media agents
# omega = 0.2 # influence strength for media
a = "none"
#opinion_listの要素数はnum_media_agentsと一致する
opinion_list = [-2/3, 0, 2/3]

method = 2
if method == 1:
  following_methods = ['Random']
elif method == 2:
  following_methods = ['Repost']
elif method == 3:
  following_methods = ['Recommendation']

media_method = 2
if media_method == 1:
  change_methods = "neighbor"
elif media_method == 2:
  change_methods = "opinion_poll"

size = [200]*num_agents + [1000]*num_media_agents

def draw_h(G, pos, measures, size, list_mode, num_agents, num_media_agents):
  if list_mode:
    result = [measures.iloc[-1, i] for i in range(G.number_of_nodes())]
    dict_measure = nx.degree_centrality(G)
    result2 = list(dict_measure.keys())
    vmin_t = -1.0
    vmax_t = 1.0
  else:
    result = measures
    result2 = [i for i in range(num_agents+num_media_agents)]
    # result = list(measures.values())
    # result2 = list(measures.keys())
    vmin_t = 0.0
    vmax_t = 60.0
  nodes = nx.draw_networkx_nodes(G, pos, node_size = size,
                                 cmap = plt.cm.plasma,                   #matplotlibのcolormapを入力
                                 node_color = result,
                                 nodelist = result2)     #posは辞書型、list(measures.values())で辞書のインデックスの方をリストに格納リストに格納
  nodes.set_norm(mcolors.SymLogNorm(linthresh = 0.1, linscale = 1, vmin = vmin_t, vmax = vmax_t))   #?
  # labels = nx.draw_networkx_labels(G, pos)
  edges = nx.draw_networkx_edges(G, pos)                               #エッジを出力
  plt.colorbar(nodes)                                                #カラーバーを出力

##########################################################################################################################################################

i = 0
plt.figure(figsize=(32,22))
for omega in range(0, 101, 25):
  i += 1
  omega = omega / 100
  # now_str = pd.datetime.now().strftime('%Y%m%d%H%M%S')
  # data_root_dir = os.path.join('data_'+''.join(now_str))
  data_root_dir = "none"
  s = datetime.datetime.now()
  d = EchoChamberDynamics(num_agents, num_media_agents, num_links, num_media_links, epsilon, sns_seed, l, data_root_dir, opinion_list)
  df_opinion, df_screen, df_media_opinion, graph = d.evolve(t_max, mu, p, q, following_methods, b, c, f, change_methods, num_agents, num_media_agents, delta, omega)
  # color_list = [e.opinion for e in d.agents] + [g.media_opinion for g in d.medias]
  e = datetime.datetime.now()
  print("  {0}/{1}".format(i, 5), "Computation Time：", e - s)
  if i == 1:
    first = s
  if i == 5:
    print("Total Computation Time", e - first)

  plt.subplot(6, 5, 5*i-4)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("agents omega = {0}".format(omega))
  plt.plot(df_opinion)

  plt.subplot(6, 5, 5*i-3)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("media omega = {0}".format(omega))
  plt.plot(df_media_opinion)

  plt.subplot(6, 5, 5*i-2)
  plt.tight_layout()
  plt.title("opinion_graph")
  df_new = pd.concat([df_opinion, df_media_opinion], axis='columns', ignore_index=True)
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, df_new, size, True, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i-1)
  plt.tight_layout()
  plt.title("in_degree_graph")
  list_new = [i[1] for i in graph.in_degree()]
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, list_new, size, False, num_agents, num_media_agents)
  # draw_h(graph, pos, graph.in_degree_centrality(), size, False, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i)
  hist_list = [i[1] for i in graph.in_degree()]
  plt.ylim(0,80)
  plt.title("in_degree histogram")
  plt.hist(hist_list, range=(0, 60), bins = [2*i for i in range(0, 31)], color='#0000CD')

dt = datetime.datetime.today()
print(dt)
plt.tight_layout(rect=[0,0,1,0.92])
plt.suptitle("\n num_agents={0}, num_links={1}, num_media_agents={2}, num_media_links={3}, screen_size={4}, t_max={5}, epsilon={6}, mu={7}, p={8}, q={9}, \n extended_model={10}, extended_media_model={11}, b={12}, c={13}, f={14}, delta={15}, omega={16}, agent_method={17}, media_method={18}".
             format(num_agents, num_links, num_media_agents, num_media_links, l, t_max, epsilon, mu, p, q, extended_model, extended_media_model, b, c, f, delta, a, following_methods, change_methods)
,fontsize=22)

# omega

num_agents = 100
num_links = 400

num_media_agents = 3
num_media_links = 120
#n_media_links/n_media_linksは整数になるべき
sns_seed = 1
l = 10 # screen size
t_max = 10000 # max steps
epsilon = 0.4 # bounded confidence parameter
mu = 0.5 # social influence strength
p = 0.5 # repost rate
q = 0.5 # rewiring rate
extended_model = False
extended_media_model = False
b = 0.1 # rate of selectable agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
c = 0.1 # rate of selectable media agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
# メディアをなくしたければf=0
f = 0.01 # media post rate
delta = 0.4 # bounded confidence parameter for media agents
# omega = 0.2 # influence strength for media
a = "none"
#opinion_listの要素数はnum_media_agentsと一致する
opinion_list = [-2/3, 0, 2/3]

method = 2
if method == 1:
  following_methods = ['Random']
elif method == 2:
  following_methods = ['Repost']
elif method == 3:
  following_methods = ['Recommendation']

media_method = 2
if media_method == 1:
  change_methods = "neighbor"
elif media_method == 2:
  change_methods = "opinion_poll"

size = [200]*num_agents + [1000]*num_media_agents

def draw_h(G, pos, measures, size, list_mode, num_agents, num_media_agents):
  if list_mode:
    result = [measures.iloc[-1, i] for i in range(G.number_of_nodes())]
    dict_measure = nx.degree_centrality(G)
    result2 = list(dict_measure.keys())
    vmin_t = -1.0
    vmax_t = 1.0
  else:
    result = measures
    result2 = [i for i in range(num_agents+num_media_agents)]
    # result = list(measures.values())
    # result2 = list(measures.keys())
    vmin_t = 0.0
    vmax_t = 60.0
  nodes = nx.draw_networkx_nodes(G, pos, node_size = size,
                                 cmap = plt.cm.plasma,                   #matplotlibのcolormapを入力
                                 node_color = result,
                                 nodelist = result2)     #posは辞書型、list(measures.values())で辞書のインデックスの方をリストに格納リストに格納
  nodes.set_norm(mcolors.SymLogNorm(linthresh = 0.1, linscale = 1, vmin = vmin_t, vmax = vmax_t))   #?
  # labels = nx.draw_networkx_labels(G, pos)
  edges = nx.draw_networkx_edges(G, pos)                               #エッジを出力
  plt.colorbar(nodes)                                                #カラーバーを出力

##########################################################################################################################################################

i = 0
plt.figure(figsize=(32,22))
for omega in range(0, 101, 25):
  i += 1
  omega = omega / 100
  # now_str = pd.datetime.now().strftime('%Y%m%d%H%M%S')
  # data_root_dir = os.path.join('data_'+''.join(now_str))
  data_root_dir = "none"
  s = datetime.datetime.now()
  d = EchoChamberDynamics(num_agents, num_media_agents, num_links, num_media_links, epsilon, sns_seed, l, data_root_dir, opinion_list)
  df_opinion, df_screen, df_media_opinion, graph = d.evolve(t_max, mu, p, q, following_methods, b, c, f, change_methods, num_agents, num_media_agents, delta, omega)
  # color_list = [e.opinion for e in d.agents] + [g.media_opinion for g in d.medias]
  e = datetime.datetime.now()
  print("  {0}/{1}".format(i, 5), "Computation Time：", e - s)
  if i == 1:
    first = s
  if i == 5:
    print("Total Computation Time", e - first)

  plt.subplot(6, 5, 5*i-4)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("agents omega = {0}".format(omega))
  plt.plot(df_opinion)

  plt.subplot(6, 5, 5*i-3)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("media omega = {0}".format(omega))
  plt.plot(df_media_opinion)

  plt.subplot(6, 5, 5*i-2)
  plt.tight_layout()
  plt.title("opinion_graph")
  df_new = pd.concat([df_opinion, df_media_opinion], axis='columns', ignore_index=True)
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, df_new, size, True, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i-1)
  plt.tight_layout()
  plt.title("in_degree_graph")
  list_new = [i[1] for i in graph.in_degree()]
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, list_new, size, False, num_agents, num_media_agents)
  # draw_h(graph, pos, graph.in_degree_centrality(), size, False, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i)
  hist_list = [i[1] for i in graph.in_degree()]
  plt.ylim(0,80)
  plt.title("in_degree histogram")
  plt.hist(hist_list, range=(0, 60), bins = [2*i for i in range(0, 31)], color='#0000CD')

dt = datetime.datetime.today()
print(dt)
plt.tight_layout(rect=[0,0,1,0.92])
plt.suptitle("\n num_agents={0}, num_links={1}, num_media_agents={2}, num_media_links={3}, screen_size={4}, t_max={5}, epsilon={6}, mu={7}, p={8}, q={9}, \n extended_model={10}, extended_media_model={11}, b={12}, c={13}, f={14}, delta={15}, omega={16}, agent_method={17}, media_method={18}".
             format(num_agents, num_links, num_media_agents, num_media_links, l, t_max, epsilon, mu, p, q, extended_model, extended_media_model, b, c, f, delta, a, following_methods, change_methods)
,fontsize=22)

# omega

num_agents = 100
num_links = 400

num_media_agents = 3
num_media_links = 120
#n_media_links/n_media_linksは整数になるべき
sns_seed = 1
l = 10 # screen size
t_max = 10000 # max steps
epsilon = 0.4 # bounded confidence parameter
mu = 0.5 # social influence strength
p = 0.5 # repost rate
q = 0.5 # rewiring rate
extended_model = False
extended_media_model = False
b = 0.1 # rate of selectable agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
c = 0.1 # rate of selectable media agent 拡張版の時にエージェントの選択確率は　b+opinion/合計
# メディアをなくしたければf=0
f = 0.05 # media post rate
delta = 0.8 # bounded confidence parameter for media agents
# omega = 0.2 # influence strength for media
a = "none"
#opinion_listの要素数はnum_media_agentsと一致する
opinion_list = [-2/3, 0, 2/3]

method = 2
if method == 1:
  following_methods = ['Random']
elif method == 2:
  following_methods = ['Repost']
elif method == 3:
  following_methods = ['Recommendation']

media_method = 2
if media_method == 1:
  change_methods = "neighbor"
elif media_method == 2:
  change_methods = "opinion_poll"

size = [200]*num_agents + [1000]*num_media_agents

def draw_h(G, pos, measures, size, list_mode, num_agents, num_media_agents):
  if list_mode:
    result = [measures.iloc[-1, i] for i in range(G.number_of_nodes())]
    dict_measure = nx.degree_centrality(G)
    result2 = list(dict_measure.keys())
    vmin_t = -1.0
    vmax_t = 1.0
  else:
    result = measures
    result2 = [i for i in range(num_agents+num_media_agents)]
    # result = list(measures.values())
    # result2 = list(measures.keys())
    vmin_t = 0.0
    vmax_t = 60.0
  nodes = nx.draw_networkx_nodes(G, pos, node_size = size,
                                 cmap = plt.cm.plasma,                   #matplotlibのcolormapを入力
                                 node_color = result,
                                 nodelist = result2)     #posは辞書型、list(measures.values())で辞書のインデックスの方をリストに格納リストに格納
  nodes.set_norm(mcolors.SymLogNorm(linthresh = 0.1, linscale = 1, vmin = vmin_t, vmax = vmax_t))   #?
  # labels = nx.draw_networkx_labels(G, pos)
  edges = nx.draw_networkx_edges(G, pos)                               #エッジを出力
  plt.colorbar(nodes)                                                #カラーバーを出力

##########################################################################################################################################################

i = 0
plt.figure(figsize=(32,22))
for omega in range(0, 101, 25):
  i += 1
  omega = omega / 100
  # now_str = pd.datetime.now().strftime('%Y%m%d%H%M%S')
  # data_root_dir = os.path.join('data_'+''.join(now_str))
  data_root_dir = "none"
  s = datetime.datetime.now()
  d = EchoChamberDynamics(num_agents, num_media_agents, num_links, num_media_links, epsilon, sns_seed, l, data_root_dir, opinion_list)
  df_opinion, df_screen, df_media_opinion, graph = d.evolve(t_max, mu, p, q, following_methods, b, c, f, change_methods, num_agents, num_media_agents, delta, omega)
  # color_list = [e.opinion for e in d.agents] + [g.media_opinion for g in d.medias]
  e = datetime.datetime.now()
  print("  {0}/{1}".format(i, 5), "Computation Time：", e - s)
  if i == 1:
    first = s
  if i == 5:
    print("Total Computation Time", e - first)

  plt.subplot(6, 5, 5*i-4)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("agents omega = {0}".format(omega))
  plt.plot(df_opinion)

  plt.subplot(6, 5, 5*i-3)
  plt.tight_layout()
  plt.xlim(0, t_max)
  plt.ylim(-1, 1)
  plt.title("media omega = {0}".format(omega))
  plt.plot(df_media_opinion)

  plt.subplot(6, 5, 5*i-2)
  plt.tight_layout()
  plt.title("opinion_graph")
  df_new = pd.concat([df_opinion, df_media_opinion], axis='columns', ignore_index=True)
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, df_new, size, True, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i-1)
  plt.tight_layout()
  plt.title("in_degree_graph")
  list_new = [i[1] for i in graph.in_degree()]
  pos=nx.nx_pydot.graphviz_layout(graph)
  draw_h(graph, pos, list_new, size, False, num_agents, num_media_agents)
  # draw_h(graph, pos, graph.in_degree_centrality(), size, False, num_agents, num_media_agents)

  plt.subplot(6, 5, 5*i)
  hist_list = [i[1] for i in graph.in_degree()]
  plt.ylim(0,80)
  plt.title("in_degree histogram")
  plt.hist(hist_list, range=(0, 60), bins = [2*i for i in range(0, 31)], color='#0000CD')

dt = datetime.datetime.today()
print(dt)
plt.tight_layout(rect=[0,0,1,0.92])
plt.suptitle("\n num_agents={0}, num_links={1}, num_media_agents={2}, num_media_links={3}, screen_size={4}, t_max={5}, epsilon={6}, mu={7}, p={8}, q={9}, \n extended_model={10}, extended_media_model={11}, b={12}, c={13}, f={14}, delta={15}, omega={16}, agent_method={17}, media_method={18}".
             format(num_agents, num_links, num_media_agents, num_media_links, l, t_max, epsilon, mu, p, q, extended_model, extended_media_model, b, c, f, delta, a, following_methods, change_methods)
,fontsize=22)

